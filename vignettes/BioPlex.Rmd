---
vignette: >
  % \VignetteIndexEntry{Data retrieval}
  % \VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  html_document:
    mathjax: null   
---

# Setup
```{r, message = FALSE}
library(BioPlex)
library(AnnotationDbi)
library(ExpressionAtlas)
library(graph)
library(org.Hs.eg.db)
library(ggplot2)
library(ggnetwork)
```

# Data resources

## BioPlex PPIs

[Available networks](https://bioplex.hms.harvard.edu/interactions.php) include: 

* BioPlex 293T cells (versions 1.0, 2.0, and 3.0)
* BioPlex HCT116 cells (version 1.0)

Let's get the latest version of the 293T PPI network:

```{r bioplex293T}
bp.293t <- getBioPlex(cell.line = "293T", version = "3.0")
head(bp.293t)
```

```{r bioplexHCT116}
bp.hct116 <- getBioPlex(cell.line = "HCT116", version = "1.0")
head(bp.hct116)
```
### ID mapping

Point out that those annotations might not be the best, they seem to leave out a bunch of mappings from Uniprot to EG (etc) that Bioc annotation finds.  

Two options for remapping (AnnotationDbi + org.db package):

1. vignette/suggests
2. within `getBioPlex` (imports, logical argument `remap.gene.ids`) 

I think we should just remap for now, but at some point we should check to see if they had a good reason to leave those out.

```{r}
bp.293t$GeneA <- AnnotationDbi::mapIds(org.Hs.eg.db, 
                                       keys = bp.293t$UniprotA, 
                                       keytype = "UNIPROT",
                                       column = "ENTREZID")
bp.293t$GeneB <- AnnotationDbi::mapIds(org.Hs.eg.db, 
                                       keys = bp.293t$UniprotB, 
                                       keytype = "UNIPROT",
                                       column = "ENTREZID")
```

### Data structures for Bioplex PPIs

We can also represent a given version of the BioPlex PPI network for a given
cell line, as one big graph where bait and prey relationship are represented 
by directed edges from bait to prey.

```{r bpgraph}
bp.gr <- bioplex2graph(bp.293t)
bp.gr
head(graph::nodeData(bp.gr))
head(graph::edgeData(bp.gr))
```

When starting off with ordinary dfs we'll be losing the ability
to annotate graph-level annotation such as cell line, version, PMID, ...
We might need to work with `DataFrame`s where we have `mcols` and `metadata`.

## CORUM complexes

Complete set of
[CORUM](http://mips.helmholtz-muenchen.de/corum/#download) complexes:

```{r corumALL}
all <- getCorum(set = "all", organism = "Human")
dim(all)
colnames(all)
all[1:5, 1:5]
```

Core set of complexes:
```{r corumCore}
core <- getCorum(set = "core", organism = "Human")
dim(core)
```

Complexes with splice variants:
```{r corumSplice}
splice <- getCorum(set = "splice", organism = "Human")
dim(splice)
```

### ID mapping

Point out that those annotations might not be the best, they seem to leave out a bunch of mappings from Uniprot to EG (etc) that Bioc annotation finds.  

Two options for remapping (AnnotationDbi + org.db package):

1. vignette/suggests
2. within `getCorum` (imports, logical argument `remap.gene.ids`) 

I think we should just remap for now, but at some point we should check to see if they had a good reason to leave those out.

### Data structures for CORUM complexes 

We can represent the CORUM complexes as list of character vectors.
The names of the list are the complex IDs/names, and each element of the list is a vector of UniProt IDs for each complex.

```{r corum2list}
core.list <- corum2list(core, subunit.id.type = "UNIPROT")
head(core.list)
length(core.list)
```

If we'd like to add metadata in a more structured form to each complex, a suitable option is a 
[GeneSetCollection](https://bioconductor.org/packages/GSEABase).

We can also represent the CORUM complexes as a list of graph instances,
where all nodes of a complex are connected to all other nodes of that complex with undirected edges.

```{r corum2glist}
core.glist <- corum2graphlist(core, subunit.id.type = "UNIPROT")
head(core.glist)
length(core.glist)
core.glist[[1]]@graphData
graph::nodeData(core.glist[[1]])
```

Identify complexes that have a subunit of interest:
```{r corum-subunit}
has.cdk2 <- hasSubunit(core.glist, 
                       subunit = "CDK2",
                       id.type = "SYMBOL")
```

Check the answer:
```{r corum-subunit2}
table(has.cdk2)
cdk2.glist <- core.glist[has.cdk2]
lapply(cdk2.glist, function(g) unlist(graph::nodeData(g, attr = "SYMBOL")))
```

Inspect the graph:
```{r corum-subunit3, message = FALSE}
plot(cdk2.glist[[1]], main = cdk2.glist[[1]]@graphData$ComplexName)
```

We can easily convert a 
[graph](https://bioconductor.org/packages/graph) object into an 
[igraph](https://cran.r-project.org/package=igraph) object:

```{r}
ig <- igraph::graph_from_graphnel(core.glist[[4]])
ig
```

This is, for example, useful for applying `igraph`-based plotting
utilities such as 
(ggnetwork)[https://cran.r-project.org/package=igraph]:

```{r}
ggplot(ig, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_edges() +
  geom_nodelabel(aes(label = SYMBOL)) +
  theme_blank()
```

Now we can also easily pull out a BioPlex subnetwork for a CORUM complex
of interest:

```{r}
n <- graph::nodes(cdk2.glist[[1]])
bp.sgr <- graph::subGraph(n, bp.gr)
bp.sgr
```

There seems to be an issue with BioPlex Uniprot IDs though, as they sometimes
extend official Uniprot IDs such as Q8N7W2 via Q8N7W2-1, Q8N7W2-2, ... which
are at least not in the Bioc mappings

```{r}
valid.uids <- AnnotationDbi::keys(org.Hs.eg.db, keytype = "UNIPROT")
"Q8N7W2" %in% valid.uids
"Q8N7W2-1" %in% valid.uids
"Q8N7W2-2" %in% valid.uids
```

## Transcriptome data

### HEK293 cells

#### GSE122425

##### Get RNA-seq data for HEK293 cells from GEO: 
[GSE122425](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE122425)

```{r gse122425}
se <- getGSE122425()
se
head(assay(se, "raw"))
head(assay(se, "rpkm"))
colData(se)
rowData(se)
```

##### Sanity check that the expressed genes are showing up as prey:

```{r prey-expression}
bait <- unique(bp.293t$SymbolA)
length(bait)
prey <- unique(bp.293t$SymbolB)
length(prey)
```

```{r}
ind <- match(prey, rowData(se)[["GeneSymbol"]])
par(las = 2)
boxplot(log2(assay(se, "rpkm") + 0.5)[ind,], 
        names = se$title, 
        ylab = "log2 RPKM")
```

How many prey genes are expressed (raw read count > 0) in all 3 WT reps:

```{r prey-expression2}
# background: how many genes in total are expressed in all three WT reps
gr0 <- rowSums(assay(se)[,1:3] > 0)
table(gr0 == 3)
# prey: expressed in all three WT reps
table(gr0[ind] == 3)
# prey: expressed in at least one WT rep
table(gr0[ind] > 0)
```

Are prey genes overrepresented in the expressed genes?
```{r prey-expression-ora}
exprTable <-
     matrix(c(9346, 1076, 14717, 32766),
            nrow = 2,
            dimnames = list(c("Expressed", "Not.expressed"),
                            c("In.prey.set", "Not.in.prey.set")))
exprTable
```

Test using hypergeometric test (i.e. one-sided Fisher's exact test):
```{r prey-expression-ora2}
fisher.test(exprTable, alternative = "greater")
```

Alternatively: permutation test, i.e. repeatedly sample number of prey genes 
from the background, and assess how often we have as many or more than 9346 genes
expressed:

```{r prey-expression-293T-perm}
permgr0 <- function(gr0, nr.genes = length(prey)) 
{
    ind <- sample(seq_along(gr0), nr.genes)
    sum(gr0[ind] == 3)
}
```

```{r prey-expression-perm2}
perms <- replicate(permgr0(gr0), 1000)
summary(perms)
(sum(perms >= 9346) + 1) / 1001
```

##### Is there a relationship between prey frequency and prey expression level?
```{r prey-freq}
prey.freq <- sort(table(bp.293t$SymbolB), decreasing = TRUE)
head(prey.freq)
summary(as.vector(prey.freq))
hist(prey.freq, breaks = 50)
```

```{r}
ind <- match(names(prey.freq), rowData(se)[["GeneSymbol"]])
par(pch = 20)
plot( as.vector(prey.freq),
      log2(assay(se, "rpkm") + 0.5)[ind, 1],
      xlab = "prey frequency",
      ylab = "log2 RPKM")
cor(as.vector(prey.freq), 
    log2(assay(se, "rpkm") + 0.5)[ind, 1],
    use = "pairwise.complete.obs")
```

Does gene length has an impact? 
```{r, eval = FALSE}
gc.gl <- EDASeq::getGeneLengthAndGCContent(names(se), 
                                           org = "hsa")
```

```{r, eval = FALSE}
rowData(se)$gc <- gc.gl$gc
rowData(se)$length <- gc.gl$length
ind <- !is.na(rowData(se)$length)
se <- se[ind,]
rowData(se)
```

```{r, eval = FALSE}
cqn.res <- cqn::cqn(assay(se), 
                lengths = rowData(se)$length,
                x = rowData(se)$gc, 
                sizeFactors = colSums(assay(se)))
```

```{r, eval = FALSE}
assay(se, "rpkm.cqn") <- cqn.res$y + cqn.res$offset
plot( as.vector(prey.freq),
      log2(assay(se, "rpkm.cqn") + 0.5)[ind, 1],
      xlab = "prey frequency",
      ylab = "log2 RPKM (length-scaled)")
cor(as.vector(prey.freq), 
    log2(assay(se, "rpkm.cqn") + 0.5)[ind, 1],
    use = "pairwise.complete.obs")
```

### HCT116 cells

#### Cancer Cell Line Encyclopedia (CCLE)

Get RNA-seq data for 934 cancer cell lines (incl. HCT116) from the 
[Cancer Cell Line Encyclopedia](https://portals.broadinstitute.org/ccle) 
as available from the [ArrayExpress-ExpressionAtlas](https://www.ebi.ac.uk/gxa) 
(Accession: [E-MTAB-2770](https://www.ebi.ac.uk/gxa/experiments/E-MTAB-2770))

```{r CCLE}
atlasRes <- ExpressionAtlas::searchAtlasExperiments(
              properties = "Cancer Cell Line Encyclopedia", 
              species = "human" )
atlasRes
ccle <- ExpressionAtlas::getAtlasData(atlasRes$Accession)
ccle <- ccle$`E-MTAB-2770`$rnaseq
ccle
```

We have raw read counts: 
```{r ccle-assay}
assay(ccle)[1:5,1:5]
colData(ccle)
```

and we have one sample per cell line:

```{r ccle-hct116}
ind <- grep("HCT 116", ccle$cell_line)
colData(ccle)[ind,]
```

#### Klijn et al., 2015

Get RNA-seq data of 675 commonly used human cancer cell lines (incl. HCT116) from [Klijn et al., 2015](https://pubmed.ncbi.nlm.nih.gov/25485619) 
as available from the [ArrayExpress-ExpressionAtlas](https://www.ebi.ac.uk/gxa) 
(Accession: [E-MTAB-2706](https://www.ebi.ac.uk/gxa/experiments/E-MTAB-2706))

```{r klijn}
klijn <- ExpressionAtlas::getAtlasData("E-MTAB-2706")
klijn <- klijn$`E-MTAB-2706`$rnaseq
klijn
```

We have raw read counts: 
```{r klijn-assay}
assay(klijn)[1:5,1:5]
colData(klijn)
```

and we have one sample per cell line:

```{r klijn-hct116}
ind <- grep("HCT 116", klijn$cell_line)
colData(klijn)[ind,]
```

Sanity check that the expressed genes are showing up as prey:

```{r prey-expression-hct116}
bait <- unique(bp.hct116$GeneA)
length(bait)
prey <- unique(bp.hct116$GeneB)
length(prey)
```

Map prey to ENSEMBL gene IDs:

```{r mapIDs-hct116}
prey <- AnnotationDbi::mapIds(org.Hs.eg.db, 
                              keytype = "ENTREZID", 
                              column = "ENSEMBL",
                              keys = as.character(prey))
prey <- unlist(unname(prey))
ind.prey <- match(prey, rownames(ccle))
```

Combine HCT-116 transcriptome from CCLE and Klijn et al. datasets:

```{r comb-hct116}
ind1 <- grep("HCT 116", ccle$cell_line)
ind2 <- grep("HCT 116", klijn$cell_line)
emat <- cbind(assay(ccle)[,ind1], assay(klijn)[,ind2])
colnames(emat) <- c("ccle", "klijn")
head(emat)
```

The CCLE and Klijn et al. measurements correlate very well:

```{r cor-ccle-klijn}
cor(emat[,"ccle"], emat[,"klijn"])
```

How many prey genes are expressed (raw read count > 0) in both CCLE and Klijn et al.?

```{r prey-expression2-hct116}
# background: how many genes in total are expressed in both measurements
gr0 <- rowSums(emat > 0)
table(gr0 == 2)
# prey: expressed in both measurements
table(gr0[ind.prey] == 2)
# prey: expressed in at least one measurement
table(gr0[ind.prey] > 0)
```

# Downstream analysis

## BioNet

## GGEA

## SGSeq

# Advanced 

## Caching

Note that calling functions like `getCorum` or `getBioPlex` with argument
`cache = FALSE` will automatically overwrite the corresponding object in your 
cache. It is thus typically not required for a user to interact with the cache.

For more extended control of the cache, use from within R:

```{r cache}
cache.dir <- tools::R_user_dir("BioPlex", which = "cache") 
bfc <- BiocFileCache::BiocFileCache(cache.dir)
```

and then proceed as described in the
[BiocFileCache vignette, Section 1.10](https://www.bioconductor.org/packages/release/bioc/vignettes/BiocFileCache/inst/doc/BiocFileCache.html#cleaning-or-removing-cache)

either via `cleanbfc()` to clean or `removebfc()` to remove your cache.

To do a hard reset (use with caution!):

```{r rmCache, eval = FALSE}
BiocFileCache::removebfc(bfc)
```

## SessionInfo

```{r sessionInfo}
sessionInfo()
```
